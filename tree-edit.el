;;; tree-edit.el --- A library for structural refactoring and editing -*- lexical-binding: t; -*-
;;
;; Copyright (C) Ethan Leba <https://github.com/ethan-leba>
;;
;; Author: Ethan Leba <ethanleba5@gmail.com>
;; Version: 0.1.0
;; Homepage: https://github.com/ethan-leba/tree-edit
;; Package-Requires: ((emacs "27.1") (tree-sitter "0.15.0") (tsc "0.15.0") (tree-sitter-langs "0.10.0") (dash "2.19") (reazon "0.4.0") (s "0.0.0"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;; Provides a set of functions for structural editing or refactoring in any
;; language supported by tree-sitter.
;;
;; The interface for this package is currently unstable, developing against it is
;; unadvised!
;;
;; See `evil-tree-edit' if you're looking for a complete editing package.
;;
;;; Code:
;;* Requires
(require 'tree-sitter)
(require 'dash)
(require 'reazon)
(require 's)

;;* Internal variables
(defvar tree-edit-grammar nil
  "The grammar rules generated by tree-sitter. Set by mode-local grammar file.")
(defvar tree-edit--supertypes nil
  "A mapping from type to supertype, i.e. if_statement is a statement. Set by mode-local grammar file.")
(defvar tree-edit--subtypes nil
  "A mapping from type to subtype, i.e. statement is subtyped by if_statement. Set by mode-local grammar file.")
(defvar tree-edit--containing-types nil
  "A mapping from a type to all possible types that can exist as it's children. Set by mode-local grammar file.")
(defvar tree-edit--alias-map nil
  "A mapping from a type to a mapping from original name to aliased name. Set by mode-local grammar file.")
(defvar tree-edit--identifier-regex nil
  "The regex used to determine if a string is an identifier. Set by mode-local grammar file.")
(defvar tree-edit--hidden-node-types nil
  "Nodes which are hidden by tree-sitter. Set by mode-local grammar file.

Unfortunately tree-sitter allows certain nodes to be hidden from
the syntax tree, which will throw off tree-edit's parser. The
best we can do for now is pretend that these nodes don't exist at
all.

https://tree-sitter.github.io/tree-sitter/creating-parsers#hiding-rules")
;; TODO: This should be mode local
(defvar tree-edit--type-cache (make-hash-table :test #'equal)
  "Caches the type and split node for a given piece of text.

This cache both as an optimization for text we copied through
tree-edit, and works around certain edge cases.")
(defvar tree-edit-parse-comments t
  "If non-nil, allow abritrary 'comment' nodes when parsing.

This should be enabled when using parser for insertions, but
seeing the comments is unnecessary when previewing the parser.")
(defvar tree-edit-node-insertion-override nil
  "A mapping from type to function, overriding `tree-edit--valid-insertions'.

Set by mode-local grammar file.

This should only be used in one of the following cases:

1. Performance, i.e. blocks or compound statements, where there
is no syntax between nodes, and the amount of nodes present can
be very high.

2. Nodes containing tree-sitter externals, so the JSON grammar
may not truly capture what qualifies as a valid node.")
(defvar tree-edit-node-deletion-override nil
  "A mapping from type to function, overriding `tree-edit--valid-deletions'.

Set by mode-local grammar file.

This should only be used in one of the following cases:

1. Performance, i.e. blocks or compound statements, where there
is no syntax between nodes, and the amount of nodes present can
be very high.

2. Nodes containing tree-sitter externals, so the JSON grammar
may not truly capture what qualifies as a valid node.")
(defvar tree-edit-node-replacement-override nil
  "A mapping from type to function, overriding `tree-edit--valid-replacement-p'.

Set by mode-local grammar file.

This should only be used in one of the following cases:

1. Performance, i.e. blocks or compound statements, where there
is no syntax between nodes, and the amount of nodes present can
be very high.

2. Nodes containing tree-sitter externals, so the JSON grammar
may not truly capture what qualifies as a valid node.")
(defvar tree-edit-significant-node-types nil
  "List of nodes that are considered significant, like methods or classes. Set by mode-local grammar file.")
(defvar tree-edit-syntax-snippets nil
  "Snippets for constructing nodes. Set by mode-local grammar file.

Must be an alist of node type (as a symbol) to list, where the list can
contain any string or a symbol referencing another node type in the alist.

The syntax snippets are intended to mirror the grammar constructions
of the tree-sitter grammar, but is currently not validated by tree-edit.")
(defvar tree-edit-nodes nil
  "Nodes that a user can create via tree-edit. Set by mode-local grammar file.

Must be a list of plists, with the following properties:

Properties
  :type           the node's type
  :key            the keybinding for the given node
  :name           human readable name for which-key, defaults to
                  :type if left unset
  :node-override  overrides syntax snippets for the verb
  :wrap-override  overrides syntax snippets for the verb when wrapping")
(defvar tree-edit-query-nodes nil
  "Nodes that users can query for jumping. Set by mode-local grammar file.

Must be a list of plists, with the following properties:

Properties
  :type           the node's type, or a list of types
  :key            the keybinding for the given node
  :name           human readable name for which-key, defaults to
                  :type if left unset")
(defvar tree-edit-whitespace-rules nil
  "Rules for formatting nodes. Set by mode-local grammar file.

Must by an alist of node type to a pair of lists, where the car
is the whitespace rules before the node, and the cdr is after.

The following keywords are valid whitespace rules:

  :newline      insert a newline before the next text
  :indent       increase the indentation by 4 for the next newline
  :dedent       decrease the indentation by 4 for the next newline")
(defvar tree-edit-placeholder-node-type nil
  "Node considered a placeholder. Set by mode-local grammar file.

Typically an identifier, but can conceivably be any type of node.")
(defvar tree-edit-dwim-node-alist nil
  "Mapping from node type to a DWIM wrapper type. Set by mode-local grammar file.

If a node cannot be inserted, but it can be inserted if wrapped
in a DWIM node, that will happen instead.")
(defvar tree-edit-indentation-level 4
  "How many spaces/tabs to indent by when rendering nodes.

Set by mode-local grammar file.

TODO: Is there a builtin way to infer this from the buffer?")

;;* User settings
(defgroup tree-edit nil
  "Structural editing library for tree-sitter languages."
  :group 'bindings
  :prefix "tree-edit-")
(defcustom tree-edit-language-alist '((java-mode . tree-edit-java)
                                      (python-mode . tree-edit-python)
                                      (c-mode . tree-edit-c))
  "Mapping from mode to language file."
  :type '(alist :key-type symbol :value-type symbol)
  :group 'tree-edit)
;; TODO: Add timeout to queries
;; (defcustom tree-edit-query-timeout 0.1
;;   "How long a query should take before giving up."
;;   :type 'float
;;   :group 'tree-edit)

(define-error 'tree-edit-transformation-error "[Failed transformation]")
(cl-defstruct (tree-edit-result)
  "The result of a sucessful structural edit."
  start-index end-index tokens)

;;* Utilities
(defun tree-edit-transformation-error (format &rest args)
  "Signal transformation error with string FORMAT formatted with ARGS."
  (signal 'tree-edit-transformation-error (list (apply #'format-message format args))))

(defun tree-edit--boring-nodep (node)
  "Check if the NODE is not a named node."
  (and (tsc-node-p node) (not (tsc-node-named-p node))))

(defun tree-edit--get-current-index (node)
  "Return a pair containing the siblings of the NODE and the index of NODE within it's parent."
  (let* ((parent (tsc-get-parent node))
         (pnodes (--map (tsc-get-nth-named-child parent it)
                        (number-sequence 0 (1- (tsc-count-named-children parent))))))
    (--find-index (equal (tsc-node-position-range node) (tsc-node-position-range it)) pnodes)))

(defun tree-edit--all-named-descendants (node)
  "Retrieve all named descendants of NODE."
  ;; Use cursor for efficiency?
  (let (result (stack `(,node)))
    (while stack
      (let* ((item (pop stack))
             (children (-filter #'tsc-node-named-p (tree-edit--get-all-children item))))
        (setq stack (append children stack))
        (setq result (append result children))))
    result))

(defun tree-edit--node-steps (node)
  "Return the sequence of steps from the root node to NODE.

Each step has the form (CHILD-NODE . NTH), where CHILD-NODE is the node to
descend into, and NTH is its 0-based ordinal position within the parent node.

If NODE is the root node, the sequence is empty."
  (let (steps parent (this node))
    (while (setq parent (tsc-get-parent this))
      (cl-block nil
        (let ((i 0))
          (tsc-mapc-children
           (lambda (child)
             (when (tsc-node-eq child this)
               (push i steps)
               (cl-return))
             (when (tsc-node-named-p child)
               (setq i (1+ i))))
           parent))
        (error "Unable to calculate node steps"))
      (setq this parent))
    steps))

(defun tree-edit--node-from-steps (steps)
  "Follow STEPS from TREE's root node; return the final node.
STEPS should be a sequence of steps, as described by `tsc--node-steps'.

If a step cannot be followed, signal a `tsc--invalid-node-step'
error. Differs from `tsc--node-from-steps' in that it does not
validate the type of the steps."
  (let ((this (tsc-root-node tree-sitter-tree)))
    (cl-dolist (step steps)
      (when (zerop (tsc-count-named-children this))
        (cl-return))
      (let ((new-node (tsc-get-nth-named-child this (min step (1- (tsc-count-named-children this))))))
        (setq this new-node)))
    this))

(defun tree-edit--apply-until-interesting (fun node)
  "Apply FUN to NODE until a named node is hit."
  (let ((parent (funcall fun node)))
    (if (tree-edit--boring-nodep parent)
        (tree-edit--apply-until-interesting fun parent)
      parent)))

(defun tree-edit-all-aliases-for-type (type)
  "Retrieve all aliases that a given node TYPE has. Useful for querying."
  (--mapcat
   (if-let (alias (alist-get type (cdr it))) `(,alias))
   tree-edit--alias-map))

(defun tree-edit--format-query-string (node-type)
  "Format a query string for NODE-TYPE.

NODE-TYPE can be a symbol or a list of symbol."
  (interactive)
  (--> (if (listp node-type) node-type `(,node-type))
       (-map (lambda (type) (format "(%s)" type)) it)
       (string-join it " ")
       ;; Query string needs an @name here, or it won't return any results
       (format "[%s] @node" it)))

(defun tree-edit-query (patterns node)
  "Execute query PATTERNS against the children of NODE and return captures.

TODO: Build queries and cursors once, then reuse them?"
  (let* ((query (tsc-make-query tree-sitter-language patterns)))
    (-map #'cdr (tsc-query-captures query node #'tsc--buffer-substring-no-properties))))

(defun tree-edit--relevant-types (type parent-type)
  "Return a list of the TYPE and all relevant types that occur in PARENT-TYPE.

Relevant types are either supertypes of TYPE or alias names referring to TYPE."
  (-intersection
   (cons
    (alist-get type (alist-get parent-type tree-edit--alias-map))
    (alist-get type tree-edit--supertypes `(,type)))
   (alist-get parent-type tree-edit--containing-types)))

(defun tree-edit-load-grammar-for-major-mode ()
  "Load the grammar for the major mode, or error if none is registered."
  (let ((language-file (alist-get major-mode tree-edit-language-alist)))
    (unless language-file
      (user-error
       "No language file specified for major mode `%s' in `tree-edit-language-alist'!"
       (symbol-name major-mode)))
    (require language-file)))

;;* Locals: node transformations


;; Error recovery seems to be a bit arbitrary:
;; - "foo.readl" in java parses as (program (expression_statement (...) (MISSING \";\")))
;; - "foo.read" in java parses as (program (ERROR (...)))
(defun tree-edit--parse-fragment (fragment)
  "Return the possible nodes of FRAGMENT, or nil if unparseable.

For example, `foo()` in Python parses as an expression_statement
with a call inside. Depending on the context, we may want either:
so we return both.

Fragments should parse as one of the following structures:
- (program (type ...)
- (program (ERROR (type ...))
- (program (... (type ...) (MISSING ...))"
  (cl-flet ((tree-edit--get-only-child
             (lambda (node) (if (equal (tsc-count-named-children node) 1)
                                (tsc-get-nth-named-child node 0)))))
    (if-let ((first-node (->> fragment
                              (tsc-parse-string tree-sitter-parser)
                              (tsc-root-node)
                              (tree-edit--get-only-child))))
        (if-let (node (if (tsc-node-has-error-p first-node)
                          (-some-> first-node
                            (tree-edit--get-only-child))
                        first-node))
            (let (result)
              (while node
                (let ((tmp (tree-edit--get-only-child node)))
                  (if (or (not result)
                          (equal (tsc-node-position-range node)
                                 (tsc-node-position-range (car result))))
                      (progn
                        (push node result)
                        (setq node tmp))
                    (setq node nil))))
              (reverse result))))))

(defun tree-edit--get-all-children (node)
  "Return all of NODE's children."
  (--map (tsc-get-nth-child node it)
         (number-sequence 0 (1- (tsc-count-children node)))))

(defun tree-edit--get-parent-tokens (node)
  "Return a pair containing the siblings of the NODE and the index of itself."
  (let* ((parent (tsc-get-parent node))
         (children (tree-edit--get-all-children parent)))
    (cons (-map #'tsc-node-type children)
          (--find-index (tsc-node-eq node it) children))))

(defun tree-edit-simple-delete-override (_ _ start-index end-index)
  "Allow deletion of NODE and surrounding syntax."
  (make-tree-edit-result :start-index start-index :end-index end-index :tokens nil))

(defun tree-edit-simple-insertion-replacement-override (type parent start-index end-index)
  "Allow insertion of TYPE if it appears in NODE's parent's grammar."
  (when-let (types (tree-edit--relevant-types type (tsc-node-type parent)))
    (make-tree-edit-result :start-index start-index :end-index (or end-index start-index) :tokens `(,type))))

;;* Globals: Syntax generation
(defun tree-edit--find-raise-ancestor (ancestor child)
  "Find a suitable ANCESTOR to be replaced with CHILD."
  (interactive)
  (let ((child-type (tsc-node-type child)))
    (cond
     ((not (and ancestor (tsc-get-parent ancestor))) (tree-edit-transformation-error "Can't raise node!"))
     ;; XXX: For cases like (expression_statement (call)), where both represent the same text.
     ;;      This might only apply to Python.
     ((equal (tsc-node-byte-range ancestor) (tsc-node-byte-range child))
      (tree-edit--find-raise-ancestor (tsc-get-parent ancestor) child))
     ((tree-edit--valid-replacement-p child-type ancestor) ancestor)
     (t (tree-edit--find-raise-ancestor (tsc-get-parent ancestor) child)))))

(defun tree-edit--valid-node-including-type (type parent-type)
  "Return a valid sequence of tokens for PARENT-TYPE containing TYPE, or nil."
  (tree-edit-load-grammar-for-major-mode)
  (-let* ((reazon-occurs-check nil)
          (grammar (alist-get parent-type tree-edit-grammar))
          (relevant-types (tree-edit--relevant-types type parent-type)))
    (car (tree-edit--run-relation 1 q
           (lambda (tokens) (and (listp tokens) (equal 1 (-count #'symbolp tokens))))
           (tree-edit--max-lengtho q 5)
           (tree-edit--includes-typeo q relevant-types)
           (tree-edit-parseo grammar q '())))))

(defun tree-edit--remove-node-and-surrounding-syntax (tokens idx)
  "Return a pair of indices to remove the node at IDX in TOKENS and all surrounding syntax."
  (let ((end (1+ idx))
        (start (1- idx)))
    (while (stringp (nth end tokens))
      (setq end (1+ end)))
    (while (and (>= start 0) (stringp (nth start tokens)))
      (setq start (1- start)))
    (cons (1+ start) end)))

(cl-defun tree-edit--attempt-structural-edit
    (parent &key (new-type nil) start-index (end-index nil) (overrides-alist nil))
  "Attempt to perform structural edit.

Returns a `tree-edit-result' if successful, otherwise nil.

This is the main interface to the miniKanren syntax relation.

Properties
  :new-type  The type to be inserted, if any
  :start-index  Where the new tokens should start
  :end-index  Where the old tokens should be removed, if set
  :overrides-alist  Alist from type to function for overrides
"
  (tree-edit-load-grammar-for-major-mode)
  (if-let (override (alist-get (tsc-node-type parent) overrides-alist))
      (funcall override new-type parent start-index end-index)
    (-let* (reazon-occurs-check
            (parent-type (tsc-node-type parent))
            (grammar (alist-get parent-type tree-edit-grammar))
            (children (-map #'tsc-node-type (tree-edit--get-all-children parent)))
            (left (-take start-index children))
            (right (-drop (or end-index start-index) children))
            (relevant-types (tree-edit--relevant-types new-type parent-type)))
      (when-let (result (tree-edit--run-relation 3 q
                          (lambda (tokens)
                            (and
                             (listp tokens)
                             (if new-type
                                 (equal 1 (-count #'symbolp tokens))
                               (-all-p #'stringp tokens))))
                          (reazon-fresh (tokens qr ql)
                            (tree-edit--superpositiono right qr parent-type)
                            (tree-edit--superpositiono left ql parent-type)
                            (tree-edit--max-lengtho q 5)
                            (if new-type (tree-edit--includes-typeo q relevant-types) #'reazon-!S)
                            (tree-edit--prefixpostfixo ql q qr tokens)
                            (tree-edit-parseo grammar tokens '()))))
        (make-tree-edit-result
         :start-index start-index
         :end-index (or end-index start-index)
         :tokens (car result))))))

(defun tree-edit--valid-replacement-p (type node)
  "Return non-nil if NODE can be replaced with a node of TYPE."
  (let* ((parent (tsc-get-parent node))
         (index (--find-index (tsc-node-eq node it) (tree-edit--get-all-children parent))))
    (tree-edit--attempt-structural-edit
     parent
     :new-type type
     :start-index index
     :end-index (1+ index)
     :overrides-alist tree-edit-node-replacement-override)))

(defun tree-edit--valid-insertions (type node &optional before)
  "Return a valid sequence of tokens containing the provided TYPE, or nil.

If BEFORE is non-nil, generate the tokens after NODE, otherwise before."
  (let* ((parent (tsc-get-parent node))
         (index (--find-index (tsc-node-eq node it) (tree-edit--get-all-children parent))))
    (tree-edit--attempt-structural-edit
     parent
     :new-type type
     :start-index (+ index (if before 0 1))
     :overrides-alist tree-edit-node-insertion-override)))

(defun tree-edit--valid-deletions (node)
  "Return a set of edits if NODE can be deleted, else nil.

If successful, the return type will give a range of siblings to
delete, and what syntax needs to be inserted after, if any."
  (-let* (((children . index) (tree-edit--get-parent-tokens node))
          ((left-idx . right-idx) (tree-edit--remove-node-and-surrounding-syntax children index)))
    (tree-edit--attempt-structural-edit
     (tsc-get-parent node)
     :start-index left-idx
     :end-index right-idx
     :overrides-alist tree-edit-node-deletion-override)))

;; NOTE: The node rendering code is pretty crappy, sorry. I'll probably rewrite this whole thing later on.
;;* Locals: node rendering
(defun tree-edit--generate-node (node-type rules &optional tokens)
  "Given a NODE-TYPE and a set of RULES, generate a node string.

If TOKENS is passed in, that will be used as a basis for node
construction, instead of looking up the rules for node-type."
  (interactive)
  (cons node-type
        (--map
         (if (and (not (keywordp it)) (symbolp it)) (tree-edit--generate-node it rules) `(,it ,it))
         ;; TODO: See if we can make it via. the parser?
         (or tokens (alist-get node-type rules)
             (user-error "No node definition for %s" node-type)))))

(defun tree-edit--needs-space-p (left right)
  "Check if the two tokens LEFT and RIGHT need a space between them.

https://tree-sitter.github.io/tree-sitter/creating-parsers#keyword-extraction"
  ;; TODO: Parse from grammar -- this is Java's identifier regex
  (let ((regex "[[:alpha:]_$][[:alpha:][:digit:]_$]*"))
    (and (stringp left)
         (stringp right)
         (< (length (s-matched-positions-all regex (string-join `(,left ,right))))
            (+ (length (s-matched-positions-all regex left))
               (length (s-matched-positions-all regex right)))))))

(defun tree-edit--whitespace-rules-for-type (type)
  "Retrieve whitespace rules for TYPE.

Will search for the most specific rule first and travel through
the TYPE's supertypes until exhausted."
  (car (-remove-item nil (--map (alist-get it tree-edit-whitespace-rules nil nil #'equal)
                                (alist-get type tree-edit--supertypes `(,type))))))

(defun tree-edit--add-whitespace-rules-to-tokens (type tokens)
  "Wrap TOKENS in the whitespace defined for TYPE, if any."
  (-let (((l . r) (tree-edit--whitespace-rules-for-type type)))
    (append l tokens r)))

(defun tree-edit--render-node (left-tokens new-tokens right-token indentation)
  "Insert NEW-TOKENS into the buffer, properly formatting as needed.

LEFT-TOKENS are used for calculating the formatting of
NEW-TOKENS, while RIGHT-TOKEN is used for adding any addition
newlines or spaces before the remaining text.

Pre-existing nodes in the tokens are assumed to be already
formatted correctly and thus are inserted as-is.

New nodes are inserted according `tree-edit-syntax-snippets'.

Text nodes (likely from the `kill-ring') are not assumed to be
formatted correctly and thus decomposed by
`tree-edit--text-to-insertable-node' into chunks where formatting
matters (i.e. expressions are left alone but blocks are split)."
  (-let* ((prev nil)
          (deferred-newline nil))
    (cl-flet ((process-tokens
               (stack do-insert do-whitespace)
               (while stack
                 (-let ((current (pop stack)))
                   ;; TODO: use `pcase'
                   (cond ((not current) '())
                         ((consp current)
                          (setq stack (append (tree-edit--add-whitespace-rules-to-tokens
                                               (car current) (cdr current))
                                              stack)))
                         ((equal current :newline)
                          (setq deferred-newline t))
                         ((equal current :indent)
                          (setq indentation (+ indentation tree-edit-indentation-level)))
                         ((equal current :dedent)
                          (setq indentation (- indentation tree-edit-indentation-level)))
                         ((stringp current)
                          (when deferred-newline
                            (when (or do-insert do-whitespace)
                              (newline)
                              (indent-line-to indentation))
                            (setq deferred-newline nil))
                          (when (and (or do-insert do-whitespace)
                                     (tree-edit--needs-space-p prev current))
                            (insert " "))
                          (when do-insert
                            (insert current))))
                   (when (or (equal :newline current) (stringp current))
                     (setq prev current))))))
      (process-tokens left-tokens nil nil)
      (process-tokens new-tokens t nil)
      (process-tokens `(,right-token) nil t))))

(defun tree-edit--text-and-type (node)
  "Return a pair of NODE and it's text."
  `(,(tsc-node-type node) ,(tsc-node-text node)))

(defun tree-edit--render-result (result parent)
  "Convert RESULT into a textual representation by editing the children of PARENT."
  (-let* ((start-index (tree-edit-result-start-index result))
          (end-index (tree-edit-result-end-index result))
          (fragment (tree-edit-result-tokens result))
          (children (tree-edit--get-all-children parent))
          (left (-map #'tree-edit--text-and-type (-slice children 0 start-index)))
          (right (-some-> end-index (nth children) (tree-edit--text-and-type)))
          (render-fragment
           (and fragment
                (tree-edit--generate-node
                 (tsc-node-type parent)
                 tree-edit-syntax-snippets
                 fragment)))
          (indentation
           (save-excursion
             (if children (goto-char (tsc-node-start-position (car children))))
             (current-indentation)))
          (start-edit
           (if (zerop start-index)
               (tsc-node-start-position parent)
             (tsc-node-end-position (nth (1- start-index) children))))
          (end-edit
           (if (nth end-index children)
               (tsc-node-start-position (nth end-index children))
             (tsc-node-end-position parent))))
    (combine-change-calls
        start-edit
        end-edit
      (save-excursion
        (goto-char start-edit)
        (delete-region start-edit end-edit)
        (tree-edit--render-node left (if fragment render-fragment) right indentation)))))

(defun tree-edit--split-node-for-insertion (node)
  "Split NODE into chunks of text as necessary for formatting."
  (let ((rules (tree-edit--whitespace-rules-for-type (tsc-node-type node))))
    (if (or (equal rules '(nil . nil)) (not rules))
        (tree-edit--text-and-type node)
      `(,(tsc-node-type node) .
        ,(if (tsc-node-named-p node)
             (-map #'tree-edit--split-node-for-insertion (tree-edit--get-all-children node))
           `(,(tsc-node-text node)))))))

(defun tree-edit--text-to-insertable-node (node text)
  "Split NODE for insertion, using TEXT instead of the current buffer.

`tsc-node-text' only operates on the current buffer so we have to
hack around that here."
  (cl-letf (((symbol-function 'tsc-node-text)
             (lambda (node)
               (tsc--without-restriction
                 ;; XXX: Byte and position aren't the same thing, apparently. Maybe this will break?
                 (pcase-let ((`(,beg . ,end) (tsc-node-byte-range node)))
                   (substring-no-properties text (1- beg) (if end (1- end) (length text))))))))
    (tree-edit--split-node-for-insertion node)))

;;* Globals: Structural editing functions
(defun tree-edit-exchange (new-node node)
  "Attempt to exchange NODE for NEW-NODE.

If NEW-NODE is a string, the tree-edit will attempt to infer the type of
the text."
  (when (tsc-node-eq node (tsc-root-node tree-sitter-tree))
    (tree-edit-transformation-error "Cannot exchange the root node!"))
  (if-let (result (tree-edit--try-transformation
                   new-node
                   (lambda (type) (tree-edit--valid-replacement-p type node))))
      (tree-edit--render-result result (tsc-get-parent node))
    (tree-edit-transformation-error "Cannot replace %s with %s!" (tsc-node-type node) new-node)))

(defun tree-edit-raise (node)
  "Move NODE up the syntax tree until a valid replacement is found."
  (let ((ancestor-to-replace (tree-edit--find-raise-ancestor (tsc-get-parent node) node)))
    (let ((node-text (tsc-node-text node))
          (ancestor-steps (tree-edit--node-steps ancestor-to-replace)))
      (tree-edit-cache-node node)
      ;; FIXME: Relational parser is being run twice
      (tree-edit-exchange node-text ancestor-to-replace)
      (tree-edit--node-from-steps ancestor-steps))))

(defun tree-edit-insert-sibling (new-node node &optional before)
  "Attempt to insert NEW-NODE adjacent to NODE.

If NEW-NODE is a string, the tree-edit will attempt to infer the type of
the text.

if BEFORE is t, the sibling node will be inserted before NODE, else after."
  (when (tsc-node-eq node (tsc-root-node tree-sitter-tree))
    (tree-edit-transformation-error "Cannot perform insertions on the root node!"))
  (if-let (result (tree-edit--try-transformation
                   new-node
                   (lambda (type) (tree-edit--valid-insertions type node before))))
      (tree-edit--render-result result (tsc-get-parent node))
    (tree-edit-transformation-error "Cannot insert %s %s %s!" new-node (if before "before" "after") (tsc-node-type node))))

(defun tree-edit-insert-sibling-dwim (new-node node &optional before)
  "Insert a node of the given NEW-NODE next to NODE.

If the insertion fails, then `tree-edit-dwim-node-alist' will be
searched. If a DWIM node is found, that node will be inserted
instead. Then the requested node will be inserted inside the
first possible location inside of the DWIM node."
  (condition-case err
      (tree-edit-insert-sibling new-node node before)
    (tree-edit-transformation-error
     (let ((node-steps (tree-edit--node-steps node)))
       ;; re-signal error?
       (if-let* ((node-type
                  (cond ((symbolp new-node) `(,new-node))
                        ((gethash new-node tree-edit--type-cache)
                         `(,(car (gethash new-node tree-edit--type-cache))))
                        (t
                         ;; not car
                         (-map #'tsc-node-type (tree-edit--parse-fragment new-node)))))
                 (dwim-node
                  (alist-get
                   (-first
                    (lambda (type) (alist-get type tree-edit-dwim-node-alist))
                    (--mapcat (alist-get it tree-edit--supertypes) node-type))
                   tree-edit-dwim-node-alist)))
           (progn
             (tree-edit-insert-sibling dwim-node node before)
             (let ((inserted-node
                    (let ((restored-node (tree-edit--node-from-steps node-steps)))
                      (if before restored-node (tsc-get-next-named-sibling restored-node)))))
               (cl-dolist (candidate (tree-edit--all-named-descendants inserted-node))
                 (ignore-errors
                   (tree-edit-exchange new-node candidate)
                   (cl-return)))))
         (signal (car err) (cdr err)))))))

(defun tree-edit--post-process-tokens (type result)
  "Replace alternate representations of TYPE in result with TYPE itself.

For example, an 'identifier' type may be represented it's
supertype (expression), so we need to replace it with the
original."
  (setf (tree-edit-result-tokens result)
        ;; TODO: Check supertype
        (-map-first #'symbolp (-const type) (tree-edit-result-tokens result)))
  result)

(defun tree-edit--try-transformation (new-node pred)
  "Run PRED on NEW-NODE and return tokens if valid.

If NEW-NODE is a symbol, the symbol will be passed directly to
the predicate.

If NEW-NODE is a list (presumably of symbols), the types will be
tried in order.

If NEW-NODE is a string, the type cache will be used if an entry
exists. Otherwise, the string will be parsed by the tree-sitter
parser."
  (cond
   ((symbolp new-node)
    (-some->> new-node
      (funcall pred)
      (tree-edit--post-process-tokens new-node)))
   ((listp new-node)
    (cl-dolist (type new-node)
      (-some->> type
        (funcall pred)
        (tree-edit--post-process-tokens type)
        (cl-return))))
   ((stringp new-node)
    (cl-block nil
      (if-let ((cached-node (gethash new-node tree-edit--type-cache)))
          (-let [(type . split-node) cached-node]
            (-some->> type
              (funcall pred)
              (tree-edit--post-process-tokens split-node)
              (cl-return))))
      (dolist (fragment-node (tree-edit--parse-fragment new-node))
        (-some->> fragment-node
          (tsc-node-type)
          (funcall pred)
          (tree-edit--post-process-tokens (tree-edit--text-to-insertable-node fragment-node new-node))
          (cl-return)))))
   (t (user-error "Bad data: %s" new-node))))

(defun tree-edit-insert-child (new-node node)
  "Attempt to insert NEW-NODE inside of NODE.

If NODE already has named children, the new node will be inserted
before the first child.

If NEW-NODE is a string, the tree-edit will attempt to infer the
type of the text."
  (if (> (tsc-count-named-children node) 0)
      (tree-edit-insert-sibling new-node (tsc-get-nth-named-child node 0) t)
    (if-let (result (tree-edit--try-transformation
                     new-node
                     (lambda (type)
                       (when-let ((tokens (tree-edit--valid-node-including-type type (tsc-node-type node))))
                         (make-tree-edit-result :tokens tokens
                                                :start-index 0
                                                :end-index (tsc-count-children node))))))
        (tree-edit--render-result result node)
      (tree-edit-transformation-error "Cannot insert %s into %s!" new-node (tsc-node-type node)))))

(defun tree-edit--get-next-node (node)
  "Get the next node to the left of NODE."
  (when-let ((parent (tsc-get-parent node)))
    (or (tsc-get-next-named-sibling parent)
        (tree-edit--get-next-node parent))))

(defun tree-edit-slurp (node)
  "Transform NODE's next sibling into it's leftmost child, if possible."
  (let ((slurp-candidate (tree-edit--get-next-node node)))
    (cond ((not slurp-candidate) (tree-edit-transformation-error "Nothing to slurp!"))
          ((zerop (tsc-count-children node)) (tree-edit-transformation-error "Current node has no children, can't slurp!"))
          ;; No named children, use insert child
          ((equal (tsc-count-named-children node) 0)
           (let ((slurper (tsc--node-steps node))
                 (slurp-text (tsc-node-text slurp-candidate)))
             (atomic-change-group
               (tree-edit-delete slurp-candidate)
               (tree-edit-insert-child slurp-text (tsc--node-from-steps tree-sitter-tree slurper)))))
          ;; Named children, use insert sibling
          (t
           (let* ((slurper (tsc-get-nth-named-child node (1- (tsc-count-named-children node))))
                  (slurper-steps (tsc--node-steps slurper))
                  (slurp-text (tsc-node-text slurp-candidate)))
             (atomic-change-group
               (tree-edit-delete slurp-candidate)
               (tree-edit-insert-sibling slurp-text (tsc--node-from-steps tree-sitter-tree slurper-steps))))))))

(defun tree-edit-barf (node)
  "Transform NODE's leftmost child into it's next sibling, if possible."
  (unless (> (tsc-count-named-children node) 0)
    (tree-edit-transformation-error "Cannot barf a node with no named children!"))
  (let ((barfer (tsc-get-parent node))
        (barfee (tsc-get-nth-named-child node (1- (tsc-count-named-children node)))))
    (unless (tree-edit--valid-deletions barfee)
      (tree-edit-transformation-error "Cannot delete %s!" (tsc-node-text barfee)))
    (cl-block nil
      (while barfer
        (let* ((barfer-steps (tsc--node-steps barfer))
               (barfee-text (tsc-node-text barfee)))
          (when (tree-edit--valid-insertions (tsc-node-type barfer)
                                             (tsc-get-nth-child node 0))
            (tree-edit-delete barfee)
            (tree-edit-insert-sibling barfee-text (tsc--node-from-steps tree-sitter-tree barfer-steps))
            (cl-return))
          (setq barfer (tsc-get-parent barfer))))
      (tree-edit-transformation-error "Cannot barf %s!" (tsc-node-type node)))))

(defun tree-edit-delete (node)
  "Delete NODE, and any surrounding syntax that accompanies it."
  (when (tsc-node-eq node (tsc-root-node tree-sitter-tree))
    (tree-edit-transformation-error "Cannot delete the root node!"))
  (if-let (result (tree-edit--valid-deletions node))
      (tree-edit--render-result result (tsc-get-parent node))
    (tree-edit-transformation-error "Cannot delete the current node")))

(defun tree-edit-cache-node (node)
  "Store a mapping from NODE's text to type."
  (interactive)
  (puthash (tsc-node-text node)
           (cons (tsc-node-type node)
                 (tree-edit--split-node-for-insertion node))
           tree-edit--type-cache))

(defun tree-edit-copy (node)
  "Copy NODE and cache it's type."
  (interactive)
  (tree-edit-cache-node node)
  (kill-ring-save (tsc-node-start-position node) (tsc-node-end-position node)))

;;* Locals: Relational parser
;; Upstream this to `reazon'?
(defmacro tree-edit--run-relation (tries var pred &rest goals)
  "Run GOALS against VAR, returning the first matching PRED.

Run PRED against TRIES answers, or all if TRIES is nil."
  (declare (indent 2))
  `(let ((,var (reazon--make-variable ',var))
         (reazon--stop-time (and reazon-timeout (+ reazon-timeout (float-time)))))
     (tree-edit--take-first (reazon--run-goal (reazon-conj ,@goals)) ,pred ,tries ,var)))

(defun tree-edit--take-first (stream pred tries var)
  "Return the first item from STREAM for which PRED returns non-nil.

Modified from `reazon--take'."
  (declare (indent 1))
  (cond
   ((funcall pred (funcall (reazon--reify var) (car stream)))
    `(,(funcall (reazon--reify var) (car stream))))
   ((or (equal 1 tries) (functionp stream) (null stream)) nil)
   (t
    (cl-block nil
      (let ((count (if tries (1- tries) -1))
            (stream (reazon--pull (cdr stream))))
        (while (and stream (not (zerop count)) (not (functionp stream)))
          (let ((reified-var (funcall (reazon--reify var) (car stream))))
            (when (funcall pred reified-var)
              (cl-return `(,reified-var))))
          (setq count (1- count))
          (setq stream (reazon--pull (cdr stream)))))))))

(reazon-defrel tree-edit-parseo (grammar tokens out)
  "TOKENS are a valid prefix of a node in GRAMMAR and OUT is unused tokens in TOKENS."
  (reazon-disj
   (if tree-edit-parse-comments
       (reazon-fresh (next)
         ;; FIXME: Should use the `extras` field from grammar
         (tree-edit--takeo 'comment tokens next)
         (tree-edit-parseo grammar next out))
     #'reazon-!U)
   (pcase grammar
     (`((type . "STRING")
        (value . ,value))
      (tree-edit--takeo value tokens out))
     (`((type . "PATTERN")
        (value . ,_))
      (tree-edit--takeo :regex tokens out))
     (`((type . "BLANK"))
      (reazon-== tokens out))
     ((and `((type . ,type)
             (value . ,_)
             (content . ,content))
           (guard (s-starts-with-p "PREC" type)))
      ;; Silence the foolish linter.
      (ignore type)
      (tree-edit-parseo content tokens out))
     (`((type . "TOKEN")
        (content . ,content))
      (tree-edit-parseo content tokens out))
     (`((type . "SEQ")
        (members . ,members))
      (tree-edit--seqo members tokens out))
     (`((type . "ALIAS")
        (content . ,_)
        (named . ,named)
        (value . ,alias-name))
      (tree-edit--takeo (if (eq named :json-false) (symbol-name alias-name) alias-name) tokens out))
     (`((type . "IMMEDIATE_TOKEN")
        (content . ,content))
      (tree-edit-parseo content tokens out))
     (`((type . "REPEAT")
        (content . ,content))
      (tree-edit--repeato content tokens out))
     (`((type . "REPEAT1")
        (content . ,content))
      (tree-edit--repeat1o content tokens out))
     (`((type . "FIELD")
        (name . ,_)
        (content . ,content))
      (tree-edit-parseo content tokens out))
     (`((type . "SYMBOL")
        (name . ,name))
      (if (member name tree-edit--hidden-node-types)
          (reazon-== tokens out)
        (tree-edit--takeo name tokens out)))
     (`((type . "CHOICE")
        (members . ,members))
      (tree-edit--choiceo members tokens out))
     (_ (error "Bad data: %s" grammar)))))

(reazon-defrel tree-edit--max-lengtho (ls len)
  "LS contains at most LEN elements."
  (cond
   ((> len 0)
    (reazon-disj
     (reazon-nullo ls)
     (reazon-fresh (d)
       (reazon-cdro ls d)
       (tree-edit--max-lengtho d (1- len)))))
   (t (reazon-nullo ls))))

(reazon-defrel tree-edit--seqo (members tokens out)
  "TOKENS parse sequentially for each grammar in MEMBERS, with OUT as leftovers."
  (if members
      (reazon-fresh (next)
        (tree-edit-parseo (car members) tokens next)
        (tree-edit--seqo (cdr members) next out))
    (reazon-== tokens out)))

(reazon-defrel tree-edit--choiceo (members tokens out)
  "TOKENS parse for each grammar in MEMBERS, with OUT as leftovers."
  (if members
      (reazon-disj
       (tree-edit-parseo (car members) tokens out)
       (tree-edit--choiceo (cdr members) tokens out))
    #'reazon-!U))

(reazon-defrel tree-edit--repeato (grammar tokens out)
  "TOKENS parse for GRAMMAR an abritrary amount of times, with OUT as leftovers."
  (reazon-disj
   (reazon-== tokens out)
   (reazon-fresh (next)
     (tree-edit-parseo grammar tokens next)
     (tree-edit--repeato grammar next out))))

(reazon-defrel tree-edit--repeat1o (grammar tokens out)
  "TOKENS parse for GRAMMAR at least once, up to an abritrary amount of times, with OUT as leftovers."
  (reazon-fresh (next)
    (tree-edit-parseo grammar tokens next)
    (tree-edit--repeato grammar next out)))

(reazon-defrel tree-edit--takeo (expected tokens out)
  "TOKENS is a cons, with car as EXPECTED and cdr as OUT."
  (reazon-conso expected out tokens))

(reazon-defrel tree-edit--prefixpostfixo (prefix middle postfix out)
  "OUT is equivalent to (append PREFIX MIDDLE POSTFIX)."
  (reazon-fresh (tmp)
    (reazon-appendo prefix middle tmp)
    (reazon-appendo tmp postfix out)))

(reazon-defrel tree-edit--includes-typeo (tokens relevant-types)
  "One of the types in RELEVANT-TYPES appears in TOKENS."
  (reazon-fresh (a d)
    (reazon-conso a d tokens)
    (reazon-disj
     (reazon-membero a relevant-types)
     (tree-edit--includes-typeo d relevant-types))))

(reazon-defrel tree-edit--superpositiono (tokens out parent-type)
  "OUT is TOKENS where each token is either itself or any relevant type occurring in PARENT-TYPE."
  (cond
   ((not tokens) (reazon-== out '()))
   ((and (not (equal (car tokens) 'comment)) (symbolp (car tokens)))
    (reazon-fresh (a d)
      (reazon-conso a d out)
      (reazon-membero a (tree-edit--relevant-types (car tokens) parent-type))
      (tree-edit--superpositiono (cdr tokens) d parent-type)))
   (t
    (reazon-fresh (a d)
      (reazon-conso a d out)
      (reazon-== a (car tokens))
      (tree-edit--superpositiono (cdr tokens) d parent-type)))))

(provide 'tree-edit)
;;; tree-edit.el ends here
