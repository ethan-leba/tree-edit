* Table of content
:PROPERTIES:
:TOC:      :include all
:END:
:CONTENTS:
- [[#table-of-content][Table of content]]
- [[#getting-started][Getting started]]
- [[#usage][Usage]]
  - [[#navigation][Navigation]]
  - [[#editing-operations][Editing operations]]
  - [[#pasting][Pasting]]
  - [[#a-note-on-raise-vs-delete-wrap-vs-insert][A note on raise vs. delete, wrap vs. insert]]
- [[#customization][Customization]]
:END:

* Getting started
=evil-tree-edit= can be installed on MELPA.
# FIXME
Many, if not all languages will require custom grammars to be installed. See how
to do that here.

After installation, add hooks for any language you'd like evil-tree-edit to
automatically enable in.

#+begin_src elisp
(add-hook 'java-mode-hook #'evil-tree-edit-mode)
#+end_src

It's also recommended to use tree-edit alongside an autoformatter in it's
current state, as tree-edit does not always produce text consistent in
formatting with the surrounding nodes.

* Usage
The concept of the *cursor*, a position in the 2D plane of text, is replaced by
the *current node*, which is a position in the syntax tree in tree-edit. All
operations unless otherwise specified are performed on the current node. To help
visualize the syntax tree, tree-edit provides @@html:<kbd>@@M-x
tree-edit-view-mode@@html:</kbd>@@ as seen in the demo GIF.

Tree-edit adopts a vim-style approach to editing, where certain operators also
require a noun. In vim's case, the nouns are text objects; In tree-edit's case,
the nouns are node types. For example,
@@html:<kbd>@@i@@html:</kbd>@@@@html:<kbd>@@v@@html:</kbd>@@ would insert a
variable declaration. Due to the fact that most languages contain a large number
of node types, and vary across languages, *using [[https://github.com/justbur/emacs-which-key][which-key]] with tree-edit is
highly recommended.*

To activate tree-edit from normal state, press @@html:<kbd>@@Q@@html:</kbd>@@,
and to return to normal state press @@html:<kbd>@@ESC@@html:</kbd>@@.

** Navigation
The navigation primitives follow the tree structure of the language.

| Operation                   | Keybind                        | Description                                                                         |
|-----------------------------+--------------------------------+-------------------------------------------------------------------------------------|
| Next                        | @@html:<kbd>@@j@@html:</kbd>@@ | Move cursor to the next sibling.                                                    |
| Previous                    | @@html:<kbd>@@k@@html:</kbd>@@ | Move cursor to the previous sibling.                                                |
| Inwards                     | @@html:<kbd>@@f@@html:</kbd>@@ | Move cursor to the first child.                                                     |
| Outwards                    | @@html:<kbd>@@h@@html:</kbd>@@ | Move cursor to the parent.                                                          |
| Jump to                     | @@html:<kbd>@@s@@html:</kbd>@@ | Avy jump to a node of /node-type/ for a node inside the current.                    |
| Outwards Significant        | @@html:<kbd>@@A@@html:</kbd>@@ | Move outwards until a significant node (e.g. function or class declaration) is hit. |
| Goto Placeholder            | @@html:<kbd>@@n@@html:</kbd>@@ | Jump to the first placeholder node within the current.                              |

The definition of a placeholder node is configurable, but generally it's the
=TREE= identifiers as seen in the GIF demo.

** Editing operations
The most important feature of tree-edit: editing the syntax tree.

For any editing operation, the syntax will be added or deleted based on the
needs of the operation. For example, when adding an additional argument to a
function, tree-edit can infer that a comma is needed based on the grammar of the
language.

=tree-edit-syntax-snippets= defines how node types will actually be represented
upon insertion: see example [[https://github.com/ethan-leba/tree-edit/blob/main/tree-edit-java.el#L29][here]].

Any transformations will be rejected if a syntactically valid result cannot be
generated.

| Operation                     | Keybind                        | Description                                                                                                            |
|-------------------------------+--------------------------------+------------------------------------------------------------------------------------------------------------------------|
| Raise                         | @@html:<kbd>@@r@@html:</kbd>@@ | Replace the current node's parent with the current node.                                                               |
| Delete                        | @@html:<kbd>@@d@@html:</kbd>@@ | Delete the current node.                                                                                               |
| Move                          | @@html:<kbd>@@m@@html:</kbd>@@ | Copy then delete the current node.                                                                                     |
| Change                        | @@html:<kbd>@@c@@html:</kbd>@@ | Delete the current node and drop into insert state. Tree state will be re-entered on @@html:<kbd>@@ESC@@html:</kbd>@@. |
| Wrap                          | @@html:<kbd>@@w@@html:</kbd>@@ | Create a new node of /node-type/ and insert the current one in it.                                                     |
| Exchange                      | @@html:<kbd>@@e@@html:</kbd>@@ | Exchange the current node with a new node of /node-type/.                                                              |
| Insert                        | @@html:<kbd>@@i@@html:</kbd>@@ | Insert a new node of /node-type/ to the right of the current.                                                          |
| Append                        | @@html:<kbd>@@a@@html:</kbd>@@ | Insert a new node of /node-type/ to the left of the current.                                                           |
| Insert Child                  | @@html:<kbd>@@I@@html:</kbd>@@ | Insert a new node of /node-type/ as a child of the current. Useful for nodes with no named children, i.e. ={}=         |
| Goto Placeholder and Change   | @@html:<kbd>@@N@@html:</kbd>@@ | Jump to the first placeholder node within the current and edit it.                                                     |
| Append Placeholder and Change | @@html:<kbd>@@x@@html:</kbd>@@ | Add a placeholder node and then immediately edit it.                                                                   |
| Slurp                         | @@html:<kbd>@@>@@html:</kbd>@@ | Grow the current node to contain the nearest right-most element.                                                       |
| Barf                          | @@html:<kbd>@@<@@html:</kbd>@@ | Shrink the current node to place it's left-most element into the parent node.                                          |
| Copy                          | @@html:<kbd>@@y@@html:</kbd>@@ | Copy the text of the current node.                                                                                     |
| Undo                          | @@html:<kbd>@@u@@html:</kbd>@@ | Undo the last operation.                                                                                               |
| Preview                       | @@html:<kbd>@@?@@html:</kbd>@@ | Preview the possible variations of the current node.                                                                   |
| Tree view                     | @@html:<kbd>@@v@@html:</kbd>@@ | Enable =tree-edit-view= or display if already enabled.                                                                 |

** Pasting
Along with the standard node-types of the given language, tree-edit has a
special node-type @@html:<kbd>@@p@@html:</kbd>@@ that will attempt to parse the
type of the most recently copied text. If a type can be identified and the
operation is valid, the copied text will be used.

** A note on raise vs. delete, wrap vs. insert

Both of the following definition for argument list produce the same result on a
textual level:

#+begin_src
argument_list = expression | seq[expression "," argument_list]
argument_list = seq[expression, repeat["," expression]]
#+end_src

However, at the tree level, these two constructions result in different ways to
modify the node.

For the first construction, you'd need to use raise/wrap to add and remove expressions:
#+begin_src
(foo, [bar]) ==raise==> (foo)
([foo])      ===wrap==> (foo, bar)
#+end_src

While for the second, you can use insert/delete.
#+begin_src
(foo, [bar]) ==delete=> (foo)
([foo])      ==insert=> (foo, bar)
#+end_src
This is something you may need to be aware of if you're running trying to
perform an operation that you think should work, but doesn't! In doubt, check
the =grammar.js= of the language.

* Customization

Currently adding customization ontop of the preset language files requires a
fair bit of boilerplate, but here's some code to get started.

#+begin_src elisp
(with-eval-after-load 'tree-edit-java
  (with-mode-local java-mode
    (setq-mode-local
     java-mode

     tree-edit-syntax-snippets
     (append
      ;; Put your snippets here
      '((identifier . ("FOOBAR")))
      tree-edit-syntax-snippets)

     tree-edit-nodes
     (append
      ;; Put your nodes here
      '((:type if_statement
         :key "z"
         :name "if-else statement"
         :node-override '((if_statement . ("if" parenthesized_expression block "else" block)))))
      tree-edit-nodes)))

  (evil-tree-edit-set-state-bindings 'java-mode))
  #+end_src

  See [[file:tree-edit-java.el]] and the docstrings of the accompanying variables
  for more information.
