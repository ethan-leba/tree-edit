Documentation on using the tree-edit library. More to come!

* Installing custom grammars

** Straight/Doom (recommended)

We can use the [[https://github.com/radian-software/straight.el][straight]] package manager to manage the tree-sitter repo
repositories and automatically build the grammar whenever a new version is
available via the =:pre-build= hook. Here's an example straight recipe:

#+begin_src elisp
'(tree-edit-python
   :host github
   :repo "tree-edit/tree-sitter-python"
   :files ("*")
   :build nil
   :pre-build
   (progn
     (require 'tree-edit-build)
     (tree-edit-compile-grammar default-directory 'rustic-mode :force)))
#+end_src

And the equivalent for Doom Emac's =package!= macro:

#+begin_src elisp
(package! tree-edit-python
    :recipe (:host github
             :repo "tree-edit/tree-sitter-python"
             :files ("*")
             :build nil
             :pre-build
             (progn
               (require 'tree-edit-build)
               (tree-edit-compile-grammar default-directory 'python-mode :force))))
#+end_src

** Manual

If you don't use straight or similar VC-based package managers, you can instead
manage the grammar repos directly:

1. =git clone= a grammar to somewhere
2. Add the following to your config:

#+begin_src elisp
(require 'tree-edit-build)
(tree-edit-compile-grammar "~/my-python-grammar" 'python-mode)
#+end_src

=tree-edit= stores a hash of the grammar so that it will only be rebuilt when
there are changes to =grammar.json=

3. Whenever an update is wanted, perform a =git pull= on the grammar repository

* Rolling your own tree-edit commands

** Evil style
Something like a [[https://github.com/noctuid/lispyville][lispyville]] may be of interest for those who prefer to be in
normal mode. Here's some simple examples of how you could implement that:

#+begin_src elisp
(evil-define-operator my/tree-edit-delete (beg end)
  "Delete node between BEG and END, if possible."
  (let ((node (tsc-get-named-descendant-for-position-range
               (tsc-root-node tree-sitter-tree) beg end)))
    (tree-edit-delete node)))

(evil-define-operator my/tree-edit-raise (beg end)
  "Raise node between BEG and END, if possible."
  (let ((node (tsc-get-named-descendant-for-position-range
               (tsc-root-node tree-sitter-tree) beg end)))
    (tree-edit-raise node)))

(evil-define-key '(normal visual) global-map "gk" #'my/tree-edit-delete)
(evil-define-key '(normal visual) global-map "g/" #'my/tree-edit-raise)
#+end_src

#+RESULTS:

One thing to be careful of is whitespace: for example if you want to raise an
identifier, typing =g/w= on a word would include the whitespace and would select
the surrounding node instead (So =g/e= should be used). Similarly with text
objects selecting the entire line.

** Emacs style

#+begin_src elisp
(defun my/tree-edit-raise-word ()
  (interactive)
  (pcase-let* ((`(,beg . ,end) (bounds-of-thing-at-point 'word))
               (node (tsc-get-named-descendant-for-position-range
                      (tsc-root-node tree-sitter-tree) beg end)))
    (tree-edit-raise node)))

(define-key (current-global-map) (kbd "M-r") #'my/tree-edit-raise-word)
#+end_src

#+RESULTS:
: my/tree-edit-raise-word

* Adding new languages to tree-edit

1. [[https://github.com/cask/cask][Install Cask]]
2. Install grammar via. above process
3. Copy one of the language files (=tree-edit-python.el= or similar)
4. Add language to =tree-edit-language-alist=
5. See what breaks!

** Customizing languages

Check out the docstrings of the variables used in =tree-sitter-python.el= and the
pre-existing language files to see how to customize languages.
